const express = require("express");
const path = require("path");
const mongoose = require("mongoose");
const Chat = require("./models/chat.js");
const methodOverride = require("method-override"); //method override is used to use put requests
const ExpressError = require("./expressError.js");


const app = express();
app.set("views", path.join(__dirname, "views"));
app.set("view engine", "ejs");

app.use(express.static(path.join(__dirname, "public")));
app.use(express.urlencoded({ extended: true }));
//method override is used to use put requests
app.use(methodOverride("_method"));

async function Main() {
    await mongoose.connect("mongodb://127.0.0.1:27017/sigma_whatsapp");
}
Main().then((res) => {
    console.log("Connection Established");
}).catch((err) => {
    console.log("Error during connetion with the database : " + err);
})

app.listen(8080, () => {
    console.log("Listening through port 8080...");
})

app.get("/", (req, res) => {
    res.send("Server is working fine");
});

/*
chat1 = new Chat({
    from : "Mihir",
    to : "Vaishali",
    message : "Lets connect database to frontend using express server...",
    created_at : new Date()  //new Date() : creates a random date and time in accordance with utc.
});
chat1.save().then((res)=>{
    console.log(res);
}).catch((err)=>{
    console.log("Error in instertion : "+err);
});
*/

// index all chat
app.get("/chats", async (req, res) => {
    let chats = await Chat.find();    // note : Chat.find() is a asynchronous function so await and async will be used
    // console.log(chats);
    res.render("index", { chats });
})

// create new chat
app.get("/chats/new", (req, res) => {
    res.render("new");
})

// thenable function are await function by default so no need to await await and async keywords
// posting new chat and insertion of new chat on mongodb database
app.post("/chats", async (req, res, next) => {
    // req sent by post is highly secured and its must be extracted by url so express should be made capable of extarcting it.
    try {
        let { from, msg, to } = req.body;     // express.urlencoded({ extended : true })
        let newChat = new Chat({
            from: from,
            message: msg,
            to: to,
            created_at: new Date()
        });

        await newChat.save()   // save is a thenaable function so awaiting for this function will take place 
        res.redirect("/chats");
    }
    catch (err) {
        next(err);
    }
});

// edit message
app.get("/chats/:id/edit", async (req, res) => {
    let { id } = req.params;
    let chat = await Chat.findById(id);
    res.render("edit.ejs", { chat });

});

//method override is used to use put requests
app.put("/chats/:id", async (req, res) => {
    let { id } = req.params;
    let { msg: newmsg } = req.body;
    // Chat.findByIdAndUpdate is asynchronous function so await and async need to be used
    let updatedChat = await Chat.findByIdAndUpdate(id, { message: newmsg }, { runValidators: true, new: true });
    console.log(updatedChat);
    res.redirect("/chats");
});

// delete or destroy chat
app.delete("/chats/:id", async (req, res) => {
    let { id } = req.params;
    // findByIdAndDelete is an asynchronous function so await and async keywords must be used.
    let deleteChat = await Chat.findByIdAndDelete(id);
    res.redirect("/chats");
});

/*
// asyncWrap function to control the error and print the error to client side :
// asynWrap is a function which takes the async function as the parameter and it returns a function whose body contains the parameter's async function with a catch block attached to it.
// the returned function is called immediately and its body calls the parameter's function but this time it attches the catch block and handles teh error.
// thus writing the catch block again and again is reduced to write it only once in the asyncWrap function.
*/

function asyncWrap(fn) {     // async wrap function which takes the async function as parameter
    return function (req, res, next) {        // it returns a function whose body call the async function and catches the error
        fn(req, res, next).catch((err) => next(err));   // the async function has been attached a catch function now and it could handle all the errors
    };
}

// show route
app.get("/chats/:id", asyncWrap(async (req, res, next) => {
    let { id } = req.params;
    // if now given id exists then mongodb does nto throw error it just gives undefined data, therefore the chat becomes undefined
    let chat = await Chat.findById(id);
    if (!chat) {
        // asynchronous error does not call next() by its own so explicitly next need to be called
        next(new ExpressError(404, "Chat Not found!!!"));
    }
    res.render("edit", { chat });     // invalid chat will result in error generated by ejs template(not by mongodb) as it can't extract properties from invalid(null) chat. 
}));

const handleValidationError = (err) => {
    console.log("It is a Validation Error!  So please follow Database constraint.");
    console.log(err.message);
}

app.use((err, req, res, next) => {
    console.log(err.name);
    // Using error name we could handle all the specific errors.
    if (err.name == "ValidationError") {
        handleValidationError(err);     // for specifiec error specific fucntion could be called which will be wraping specific desired steps to be executed.
    }
    next(err);
});

app.use((err, req, res, next) => {
    let { status = 500, message = "Sorry for Internal Server Error!" } = err;
    res.status(status).send(message);
});

